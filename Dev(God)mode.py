#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë ‚ñà‚ñë‚ñë‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà.‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñî‚ñà‚ñë‚ñë‚ñà‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñÅ‚ñà‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
#‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà
#‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñà‚ñë‚ñà
#‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚ñà‚ñà‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚ñë‚ñà‚ñë‚ñà‚ñë‚ñà
#‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚ñë‚ñà‚ñë‚ñà‚ñë‚ñà
#‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà
#H:Mods Team [üíé]


# meta developer: @nullmod
from .. import loader, utils
@loader.tds
class devmode(loader.Module):
    """–ú–æ–¥—É–ª—å –¥–ª—è –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è, –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö(–¥–∞—Ç–∞–±–∞–∑–∞, –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∫–ª–∞—Å—Å–∞) –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª–µ–π"""
    strings = {
        "name": "Dev(god)mode",
        "notExist": " module does not exist"
    }
    strings_ru = {
        "notExist":" –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
    }
    
    @loader.command(
    ru_doc="[–ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥—É–ª—è/–ü—É—Å—Ç–æ] –æ—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é"
    )
    async def inspect(self,message):
        """[module/`empty`] open menu."""
        args = utils.get_args_raw(message)
        if args:
            if not self.lookup(args):#self.allmodules.lookup(args):
                await message.edit("<emoji document_id=5210952531676504517>üö´</emoji> "+args+self.strings("notExist"))
                return
            await self.setMenu(message,args)
        else:
            await self.setMenu(message)
    
    async def setMenu(self,message=None,module=None):
        if module:#set reply markup for module
            raw_vars,db = await self.getRaw(module,alldb)
            filtered = await self.filter(raw_vars)
            await m.edit(f"filtered: {filtered}\n\ndb: {bd}")
            
        else:#set reply markup for list of modules
            await m.edit(f"test: {41+1}")
            
    
    async def getRaw(self,module,alldb):
        module = self.lookup(module).name#–¥–± —Ä–µ–≥–∏—Å—Ç—Ä–æ–∑–∞–≤–∏—Å–∏–º–∞—è —Å–æ—Å–æ
        return dir(self.lookup(module)), next((n for n in alldb if n[0] == module), None)
        
    async def filter(self,vars):
        filtered = {
            "readableVars": {},
            "externalVars": {},
            "func": {},
            "config": {},
            "hikka": {},
        }
        for key,val in data.items():
            if key == "config" and isinstance(val, dict):
                result["config"] = val
                continue
            if "db" in key and not isinstance(val, (str, int)):
                continue
            if callable(val):
                filtered["functions"][key] = val
                continue
            if basicVar(val):
                filtered["readableVars"][key] = val
            else:
                filtered["externalVars"][key] = val
        return filtered